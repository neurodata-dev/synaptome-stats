---
title: "Synapse Clustering: Y2 Progress Report"
author: "Jesse Leigh Patsolic"
date: '`r Sys.Date()`'
output:
  html_document:
    fig_caption: yes
    fig_height: 4
    fig_width: 4
    fig_retina: 2
    highlight: pygments
    keep_md: yes
    number_sections: yes
    theme: cerulean
    toc: yes
    toc_depth: 3
    mode: standalone
  pdf_document:
    fig_caption: yes
    keep_tex: yes
    number_sections: yes
---
```{r render, eval=FALSE, echo=FALSE}
require(rmarkdown)
rm(list=ls()); 
rmarkdown::render("./Y2progress.Rmd")
system('open Y2progress.html')
```
```{r setup,include=TRUE,results='asis',message=FALSE,warning=FALSE}
suppressMessages(require(Matrix))
suppressMessages(require(colorRamps))
suppressMessages(require(corrplot))
suppressMessages(require(gplots))
suppressMessages(require(dplyr))
suppressMessages(require(reshape2))
suppressMessages(require(ggplot2))
suppressMessages(require(lattice))
suppressMessages(require(latticeExtra))
suppressMessages(require(hexbin))
suppressMessages(require(parallel))
suppressMessages(require(data.table))
suppressMessages(require(fpc))
suppressMessages(require(repr))
suppressMessages(require(doMC))
suppressMessages(require(aplpack))
suppressMessages(require(rgl))
suppressMessages(require(rglwidget))
source("./bic.r")
source("./clusterFraction.r")
#source("http://www.cis.jhu.edu/~parky/Synapse/getElbows.R")
source("./getElbows.r")
registerDoMC(6)

library(rmarkdown)
library(knitr)
```
```{r knitr-setup, results='asis'}
knitr::opts_chunk$set(cache=TRUE, autodep=TRUE)
dep_auto() # figure out dependencies automatically
opts_chunk$set(cache=FALSE,echo=TRUE,warning=FALSE,message=FALSE,comment="#",fig.path='../Figures/Y2progress_figure/',dpi=227,dev=c('png','pdf'))

opts_knit$set(aliases=c(h='fig.height', w='fig.width', cap='fig.cap', scap='fig.scap'))                                                                               
opts_knit$set(eval.after = c('fig.cap','fig.scap'))                                                                            
knit_hooks$set(document = function(x) {
  gsub('(\\\\end\\{knitrout\\}[\n]+)', '\\1\\\\noindent ', x)                                                   })
#opts_knit$set(animation.fun = hook_scianimator)

knit_hooks$set(plot = function(x, options) {
       paste('<figure><img src="',
             opts_knit$get('base.url'), paste(x, collapse = '.'),
             '"><figcaption>', options$fig.cap, '</figcaption></figure>',
             sep = '')
 })
 
 fn = local({
   i = 0
   function(x) {
     i <<- i + 1
     paste('Figure ', i, ': ', x, sep = '')
   }
 })

 fig <- local({
    i <- 0
    ref <- list()
    list(
        cap=function(refName, text) {
            i <<- i + 1
            ref[[refName]] <<- i
            paste("<b>Figure ", i, ": ", text, "</b><br><br>", sep="")
        },
        ref=function(refName) {
            ref[[refName]]
        })
})

```

# Introduction

> On Fri, Dec 11, 2015 at 11:53 AM, joshua vogelstein <jovo@jhu.edu> wrote:  
> we will get n=10^6 points, each in d=25 dimensions.  
> i want to hierarchically cluster them, in a ways:  

1. recursive k-means on the data, maybe 5 levels
2. compute approximate k-neighbors, svd in d=dimensions, and then #1
3. maybe some other ways.

# Data
> This corresponds to 24 channels x 6 features per synapse, ordered like
> c0f0,c0f1,c0f2,c0f3,c0f4,c0f5,c1f0,c1f1... etc
>
>f0 = integrated brightness  
>f1 = local brightness  
>f2 = distance to Center of Mass  
>f3 = moment of inertia around synapsin maxima  
>f4,f5 are features that I forget what they are.. would need to ask brad.   
>i would throw them out, I did so in my kohonen code (which you have, its in matlab).

and

> On Feb 8, 2016, at 2:00 PM, Kristina Micheva <kmicheva@stanford.edu> wrote:

* <FONT COLOR=#197300>_Excitatory presynaptic: 'Synap', 'Synap', 'VGlut1', 'VGlut1', 'VGlut2'_</FONT>,
* <FONT COLOR=#5ed155>_Excitatory postsynaptic: 'psd', 'glur2', 'nmdar1', 'nr2b', 'NOS', 'Synapo'_</FONT> (but further away than PSD, gluR2, nmdar1 and nr2b)
* <FONT COLOR=#660000>_Inhibitory presynaptic: 'gad', 'VGAT', 'PV'_</FONT>,
* <FONT COLOR=#ff3333>_Inhibitory postsynaptic: 'Gephyr', 'GABAR1', 'GABABR', 'NOS'_</FONT>,
* <FONT COLOR=#ff9933>_At a very small number of inhibitory: 'Vglut3' (presynaptic), 'CR1'(presynaptic)_</FONT>,
* <FONT COLOR="mediumblue">_Other synapses:'5HT1A', 'TH', 'VACht'_</FONT>,
* <FONT COLOR="gold">_Not at synapses: 'tubuli', 'DAPI'_</FONT>.

and 

> On March 10, 2016, 00:29:04 (UTC), Kristina Micheva <kmicheva@stanford.edu> wrote:

There are 2 different Synap channels (2 different antibodies were
used), so that part is fine.
And 2 different VGluT1 channels (same antibody but done at different
times)
The NOS channel is the same, so count it as one even though it appears
twice. It is listed two times because it can be found at both excitatory
and inhibitory synapses. This is where your count of 25 comes, even
though there are 24 channels.
I would also add the 2 Synap channels to the Inhibitory presynaptic
category - there is supposed to be synapsin there, but at lower levels
compared to excitatory presynaptic category.

- Note:  The order of the channels are given by line `227` in the `kohenen.m` file which can be found in the dropbox folder. 
- `Synap` and `Synap` have been augmented to `Synap_1` and `Synap_2` for clarity. 
- `VGlut1` and `VGlut1` have been augmented to `VGlut1_t1` and `VGlut1_t2` to distinguish between the different times of collection (which are unknown).

```{r cc_data, eval=TRUE}
feat <- fread("../Data/synapsinR_7thA.tif.Pivots.txt.2011Features.txt",showProgress=FALSE)
dim(feat)
channel <- c('Synap_1','Synap_2','VGlut1_t1','VGlut1_t2','VGlut2','Vglut3',
              'psd','glur2','nmdar1','nr2b','gad','VGAT',
              'PV','Gephyr','GABAR1','GABABR','CR1','5HT1A',
              'NOS','TH','VACht','Synapo','tubuli','DAPI')
channel.type <- c('ex.pre','ex.pre','ex.pre','ex.pre','ex.pre','in.pre.small',
                  'ex.post','ex.post','ex.post','ex.post','in.pre','in.pre',
                  'in.pre','in.post','in.post','in.post','in.pre.small','other',
                  'ex.post','other','other','ex.post','none','none')
nchannel <- length(channel)
nfeat <- ncol(feat) / nchannel
ffchannel <- (factor(channel.type,
    levels= c("ex.pre","ex.post","in.pre","in.post","in.pre.small","other","none")
    ))
fchannel <- as.numeric(factor(channel.type,
    levels= c("ex.pre","ex.post","in.pre","in.post","in.pre.small","other","none")
    ))
ford <- order(fchannel)
Syncol <- c("#197300","#5ed155","#660000","#cc0000","#ff9933","mediumblue","gold")
ccol <- Syncol[fchannel]

exType <- factor(c(rep("ex",11),rep("in",6),rep("other",7)),ordered=TRUE)
exCol<-exType;levels(exCol) <- c("#197300","#990000","mediumblue");
exCol <- as.character(exCol)

fname <- as.vector(sapply(channel,function(x) paste0(x,paste0("F",0:5))))
names(feat) <- fname
fcol <- rep(ccol, each=6)
mycol <- colorpanel(100, "purple", "black", "green")
mycol2 <- matlab.like(nchannel)
```

## Transformations

We will consider only the `f0` (integrated brightness) features, and will transform the raw data by
filtering 
Each of the channels has an arbitrary independent linear transformation and thus
converting to z-scores or quantiles is required.


```{r cc_featF0, eval=TRUE}
f0 <- seq(1,ncol(feat),by=nfeat)
featF0 <- subset(feat, select=f0)
f01e3 <- 1e3*data.table(apply(X=featF0, 2, function(x){((x-min(x))/(max(x)-min(x)))}))

fs <- f01e3
### Taking log_10 on data + 1.
flog <- log10(f01e3 + 1)
```

We now have the following data sets:

- `featF0`: Raw data looking only at the integrated brightness features.
- `fs`: Raw data scaled between $[0,1000]$.
- `flog`: $log_{10}$ of `fs`

### Kernel Density Estimates of the marginals

```{r cc_kde1, eval=TRUE, cache=FALSE,w=20,h=10,fig.cap=fig$cap("flogKDE","Kernel density estimates for each channel, on log_10 data.")}
df <- melt(as.matrix(fs))
names(df) <- c("ind","channel","value")
lvo <- c(1:5,7:10,19,22,11:16,6,17,18,20,21,23,24)
levels(df$channel)<-levels(df$channel)[lvo]
ts <- 22
gg1 <- ggplot(df, aes(x=value)) + 
    scale_color_manual(values=ccol[lvo]) +
    scale_fill_manual(values=ccol[lvo]) +
    geom_histogram(aes(y=..density..,group=channel,colour=channel),bins=100) +
    geom_density(aes(group=channel, color=channel),size=1.5) +
    facet_wrap( ~ channel, scale='free') +
    theme(plot.title=element_text(size=ts),
          axis.title.x=element_text(size=ts),
          axis.title.y=element_text(size=ts),
          legend.title=element_text(size=ts),
          legend.text=element_text(size=ts-2),
          axis.text=element_text(size=ts-2),
          strip.text=element_text(size=ts), 
          legend.position='none')+
    ggtitle("Kernel Density Estimates of scaled[0,1e3] data ")

print(gg1)
```

```{r cc_kde2, eval=FALSE,echo=FALSE,cache=FALSE,w=20,h=10,fig.cap=fig$cap("flogsKDE","Kernel density estimates for each channel, on log_10 ยบ scaled[0,1e3]+1 data.")}
df <- melt(as.matrix(flog))
names(df) <- c("ind","channel","value")
ts <- 22
gg2 <- ggplot(df, aes(x=value)) + 
    scale_color_manual(values=ccol[lvo]) +
    scale_fill_manual(values=ccol[lvo]) +
    geom_histogram(aes(y=..density..,group=channel,colour=channel),bins=100) +
    geom_density(aes(group=channel, color=channel),size=1.5) +
    facet_wrap(~ channel, scale='free') +
    theme(plot.title=element_text(size=ts),
          axis.title.x=element_text(size=ts),
          axis.title.y=element_text(size=ts),
          legend.title=element_text(size=ts),
          legend.text=element_text(size=ts-2),
          axis.text=element_text(size=ts-2),
          strip.text=element_text(size=ts), 
          legend.position='none')+
    ggtitle("Kernel Density Estimates of log_10 ยบ scaled[0,1e3]+1 data ")

print(gg2)
```

## Correlations

```{r cc_corLog, eval=TRUE,fig.cap=fig$cap("corLOG","Correlation on log_10  data, reordered by synapse type.")}
tmp <- as.numeric(table(fchannel))
cmatflog <- cor(flog)
corrplot(cmatflog[ford,ford],method="color",tl.col=ccol[ford])
corrRect(tmp,col=Syncol,lwd=4)
```

### PCA on the Correlation Matrix

```{r pcaLog, eval=TRUE}
pcaLog <- prcomp(cmatflog,scale=TRUE, center=TRUE)
elLog <- getElbows(pcaLog$sdev, plot=FALSE) 
```

### Plots of embeddings

```{r cc_2dEmb, h=5,w=5}
plot(pcaLog$x[,1:2],
     col=ccol,
     pch=as.numeric(exType)+15,
     cex=2,
     xlim=c(min(pcaLog$x[,1])-0.5,max(pcaLog$x[,1])+0.5),
     main="Embedding of PCA log_10 correlation data")
text(pcaLog$x[,1:2],col=ccol,label=abbreviate(channel),offset=1, pos=4)
```

```{r cc_3dLog}
pca <- pcaLog$x
rgl::plot3d(pca[,1],pca[,2],pca[,3],type='s', col=ccol, size=1, main="Log")
rgl::rgl.texts(pca[,1],pca[,2],pca[,3], abbreviate(channel[ford]), col=ccol, adj=c(0,1.5))
subid <- currentSubscene3d()
rglwidget(elementId="plot3dLog")
```

## K-Means Level 1

Next we run the K-means algorithm to cluster the data into K clusters.

** <FONT COLOR=#ff3333> Note that a seed is being set for the random initialization of K-means. </FONT> **

```{r cc_kmeans,eval=TRUE,echo=TRUE}
K1 <- 9  ## Set the upperbound for k-means.

## Run kmeans on the scaled data
kvecfs <- foreach(i = 1:K1) %dopar% {
    set.seed(2^13 - 1)
    kmeans(fs,centers=i)
}
## Run kmeans on the untransformed data
kvecflog <- foreach(i = 1:K1) %dopar% {
    set.seed(2^13 - 1)
    kmeans(flog,centers=i)
}
```


### Heat maps: scaled data.

For the following we manualy choose 2 clusters.

```{r cc_agg, eval=TRUE}
## Formatting data for heatmap
aggfs <- aggregate(fs,by=list(lab=kvecfs[[2]]$cluster),FUN=mean)
aggfs <- as.matrix(aggfs[,-1])
rownames(aggfs) <- clusterFraction(kvecfs[[2]])

aggflog <- aggregate(flog,by=list(lab=kvecflog[[2]]$cluster),FUN=mean)
aggflog <- as.matrix(aggflog[,-1])
rownames(aggflog) <- clusterFraction(kvecflog[[2]])

ford <- order(fchannel)
```

```{r cc_km1-heatmap,eval=FALSE,echo=FALSE,w=6,h=6,fig.cap=fig$cap("heat1", "Heatmap of the cluster means vs channels. Rows and columns are rearranged according to hclust.")}
heatmap.2(as.matrix(aggfs), trace="none",col=mycol,colCol=ccol,cexRow=0.8, keysize=1,symkey=FALSE,symbreaks=FALSE,scale="none", srtCol=90) # 
```

```{r cc_km1-heatmapSorted,eval=TRUE,w=6,h=6,fig.cap=fig$cap("heatFS1", "Heatmap of the cluster means vs channels. Rows and columns are rearranged according to synapse type.")}
heatmap.2(as.matrix(aggfs[,ford]),dendrogram='row',Colv=NA,trace="none", col=mycol,colCol=ccol[ford],cexRow=0.8, keysize=1.25,symkey=FALSE,symbreaks=FALSE,scale="none", srtCol=90,main="Heatmap of scaled data.") 
```

```{r cc_km2-heatmapSorted,eval=TRUE,w=6,h=6,fig.cap=fig$cap("heatFLOG1", "Heatmap of the cluster means vs channels. Rows and columns are rearranged according to synapse type.")}
heatmap.2(as.matrix(aggflog[,ford]),dendrogram='row',Colv=NA,trace="none", col=mycol,colCol=ccol[ford],cexRow=0.8, keysize=1.25,symkey=FALSE,symbreaks=FALSE,scale="none", srtCol=90,main="Heatmap of log_10 data.") 
```


# Exploring pair-wise relationships with `GABABR`

```{r gabLat}
set.seed(2^13 - 2)
s1 <- sample(dim(fs)[1],1e5)
dfs <- as.matrix(fs[s1,])
dflog <- as.matrix(flog[s1,])

## re-formatting data for use in lattice 
c1 <- combn(24,2)
gc1 <- which(c1 == 16, arr.ind=TRUE)[,2]


dfs2 <- foreach(i = gc1,.combine=rbind)%do%{
    colset1 <- as.matrix(dfs[,c1[,i]])
    colnames(colset1) <- NULL
    l <- paste(channel[c1[,i]][2],channel[c1[,i][1]],sep='~')
    data.frame(colset1,l,check.names=FALSE)
}
colnames(dfs2) <- c("x", "y", "g")

dflog2 <- foreach(i = gc1,.combine=rbind)%do%{
    colset1 <- as.matrix(dflog[,c1[,i]])
    colnames(colset1) <- NULL
    l <- paste(channel[c1[,i]][2],channel[c1[,i][1]],sep='~')
    data.frame(colset1,l,check.names=FALSE)
}
colnames(dflog2) <- c("x", "y", "g")

rg1 <- xyplot(y ~ x | g, data=dfs2,
       as.table=TRUE,
       colramp=BTC,
       pch='.',
       scales = list(y = list(relation = "free"),x = list(relation = "free")),
       panel=function(x,y,...){
           panel.hexbinplot(x,y,...)
           panel.loess(x,y,col='red', lwd=2,...)
        }
       )

rg2 <- xyplot(y ~ x | g, data=dflog2,
       as.table=TRUE,
       colramp=BTC,
       pch='.',
       scales = list(y = list(relation = "free"),x = list(relation = "free")),
       panel=function(x,y,...){
           panel.hexbinplot(x,y,...)
           panel.loess(x,y,col='red', lwd=2,...)
        }
       )
```

```{r rg2,eval=TRUE,echo=FALSE,w=10,h=10,fig.cap=fig$cap("rg2", "Lattice plot of pairwise regressions")}
print(rg2)
```


<footer>
<p> [Back to top][Introduction]</p>
</footer>
