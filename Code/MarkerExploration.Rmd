---
title: "Synaptome Stats: Marker Exploration"
author: "Jesse Leigh Patsolic"
date: '`r Sys.Date()`'
output:
  html_document:
    fig_caption: yes
    fig_height: 5
    fig_width: 5
    fig_retina: 2.7
    highlight: pygments
    keep_md: yes
    number_sections: yes
    theme: cerulean
    toc: yes
    toc_depth: 3
  pdf_document:
    fig_caption: yes
    keep_tex: yes
    number_sections: yes
---
```{r render, eval=FALSE, echo=FALSE}
require(rmarkdown)
rm(list=ls()); 
system.time(rmarkdown::render(grep("MarkerExploration.Rmd", dir(), value=TRUE)))
system('open MarkerExploration.html')
```
```{r setup,include=FALSE,results='asis',message=FALSE}
### Library calls here.
library(rmarkdown)
library(knitr)
require(ggplot2)
require(gridExtra)
require(gplots)
require(lattice)
require(hexbin)
require(data.table)
library(deldir) # for voronoi
require(dplyr)
require(energy)
require(lattice)
require(colorRamps)
require(corrplot)
require(rgl)
require(rglwidget)
require(doMC); registerDoMC(6)
require(foreach)
require(MASS)

source("kmpp.r")
source("clusterFraction.r")
source("KnitrOptions.r")
source("http://www.cis.jhu.edu/~parky/Synapse/getElbows.R")
```

```{r knitrOpts, include=FALSE, results='asis', message=FALSE, warning=FALSE}
source("KnitrOptions.r")
```

[Homepage](http://docs.neurodata.io/synaptome-stats/)  
The formatted source code for this file is [here](https://github.com/neurodata/synaptome-stats/blob/gh-pages/Code/MarkerExploration.Rmd).  
And a raw version [here](https://raw.githubusercontent.com/neurodata/synaptome-stats/gh-pages/Code/MarkerExploration.Rmd).    
Previous work by Youngser Park can be found [here](http://www.cis.jhu.edu/~parky/Synapse/synapse.html).  

# Data 

Here we read in the data and select a random half of it for exploration. 

```{r cc-data, eval=TRUE}
featFull <- fread("../data/synapsinR_7thA.tif.Pivots.txt.2011Features.txt",showProgress=FALSE)

### Setting a seed and creating an index vector
### to select half of the data
set.seed(2^10)
half1 <- sample(dim(featFull)[1],dim(featFull)[1]/2)
half2 <- setdiff(1:dim(featFull)[1],half1)

feat <- featFull[half1,]
dim(feat)

## Setting the channel names
channel <- c('Synap_1','Synap_2','VGlut1_t1','VGlut1_t2','VGlut2','Vglut3',
              'psd','glur2','nmdar1','nr2b','gad','VGAT',
              'PV','Gephyr','GABAR1','GABABR','CR1','5HT1A',
              'NOS','TH','VACht','Synapo','tubuli','DAPI')

## Setting the channel types
channel.type <- c('ex.pre','ex.pre','ex.pre','ex.pre','ex.pre','in.pre.small',
                  'ex.post','ex.post','ex.post','ex.post','in.pre','in.pre',
                  'in.pre','in.post','in.post','in.post','in.pre.small','other',
                  'ex.post','other','other','ex.post','none','none')

nchannel <- length(channel)
nfeat <- ncol(feat) / nchannel

## Createing factor variables for channel and channel type sorted properly
ffchannel <- (factor(channel.type,
    levels= c("ex.pre","ex.post","in.pre","in.post","in.pre.small","other","none")
    ))
fchannel <- as.numeric(factor(channel.type,
    levels= c("ex.pre","ex.post","in.pre","in.post","in.pre.small","other","none")
    ))
ford <- order(fchannel)


## Setting up colors for channel types
Syncol <-  c("#197300","#5ed155","#660000","#cc0000","#ff9933","#0000cd","#ffd700")
Syncol3 <- c("#197300","#197300","#cc0000","#cc0000","#0000cd","#0000cd","#0000cd")
ccol <- Syncol[fchannel]
ccol3 <- Syncol3[fchannel]

exType <- factor(c(rep("ex",11),rep("in",6),rep("other",7)),ordered=TRUE)
exCol<-exType;levels(exCol) <- c("#197300","#990000","#0000cd");
exCol <- as.character(exCol)

fname <- as.vector(sapply(channel,function(x) paste0(x,paste0("F",0:5))))
names(feat) <- fname
fcol <- rep(ccol, each=6)
mycol <- colorpanel(100, "purple", "black", "green")
mycol2 <- matlab.like(nchannel)
mycol3 <- colorpanel(100, "blue","white","red")
```

## Data transformations

```{r cc-datatrans, eval=TRUE}
f <- lapply(1:6,function(x){seq(x,ncol(feat),by=nfeat)})
featF <- lapply(f,function(x){subset(feat,select=x)})

featF0 <- featF[[1]]
f01e3 <- 1e3*data.table(apply(X=featF0,2,function(x){((x-min(x))/(max(x)-min(x)))}))

fs <- f01e3

### Taking log_10 on data + 1.
log1f <- log10(featF0 + 1)
slog1f <- data.table(scale(log1f, center=TRUE,scale=TRUE))
```

We now have the following data sets:

- `featF0`: The feature vector looking only at the integrated brightness features.
- `fs`:  The feature vector scaled between $[0,1000]$.
- `logf1`: The feature vector, plus one, then $log_{10}$ is applied. 
- `slog1f`: The feature vector, plus one, $log_{10}$, then scaled by
  subtracting the mean and dividing by the sample standard deviation.

# Marker Exploration 

## Correlation Matrix of markers 

```{r cc_corRawF0,w=7,h=7, eval=TRUE,fig.cap=fig$cap("corr","Correlation on untransformed F0 data, reordered by synapse type.")}
corrf <- cor(featF[[1]])[ford,ford]
corrplot(corrf,method="color",tl.col=ccol[ford], tl.cex=0.8)
corLog <- cor(slog1f)
```

```{r cc_corRawF0-5,w=24,h=24, eval=TRUE,fig.cap=fig$cap("corr","Correlation on untransformed data F0-5, reordered by synapse type.")}
bford <- order(rep(fchannel,each=6))
nord <- Reduce('c', f)
cr <- rep(ccol, each=6)
corrfB <- cor(feat)[bford,bford]
#corrfB <- cor(feat)[nord,nord]
corrplot(corrfB,method="color",tl.col=cr[bford],tl.cex=0.8)
#corrplot(corrfB,method="color",tl.col=cr[nord],tl.cex=0.8)
```

## Energy Matrix: Distance Correlation T-test

```{r cc-dcov,eval=TRUE,echo=TRUE}
set.seed(317)
sam1 <- sample(dim(featF0)[1], 1e3)
tmp <- as.data.frame((featF0[sam1,]))

set.seed(331)
combcols <- t(combn(24,2))

dc <- foreach(i = 1:dim(combcols)[1]) %dopar% {
       #dcov.test(x=tmp[,combcols[i,1]],y=tmp[,combcols[i,2]])
       dcor.ttest(x=tmp[,combcols[i,1]],y=tmp[,combcols[i,2]])
       }

ms <- matrix(as.numeric(0),24,24)
mp <- matrix(as.numeric(0),24,24)

for(i in 1:length(dc)){
    ms[combcols[i,1],combcols[i,2]] <- dc[[i]]$statistic
    ms[combcols[i,2],combcols[i,1]] <- dc[[i]]$statistic
    mp[combcols[i,1],combcols[i,2]] <- dc[[i]]$p.val
    mp[combcols[i,2],combcols[i,1]] <- dc[[i]]$p.val
}

rownames(ms) <- colnames(featF0)
rownames(mp) <- colnames(featF0)
colnames(ms) <- colnames(featF0)
colnames(mp) <- colnames(featF0)

diag(ms) <- as.numeric(0)
diag(mp) <- as.numeric(1)
```

```{r cc-energyplot,h=7,w=14,fig.cap=fig$cap("enplt","F0: Distance correlation t-test statistic and p-value matrices.")}
cl5 <- colorRampPalette(c("white", "blue"))
bl5 <- colorRampPalette(c("blue", "red"))

par(mfrow=c(1,2))
corrplot(ms[ford,ford],is.corr=FALSE,method="color",tl.col=ccol[ford], 
         tl.cex=0.8, mar=c(0,0,1,0),oma=c(0,0,2,0))
title("Test statistic") 
#corrRect(tmp,col=Syncol,lwd=4; rm(tmp))
corrplot((mp[ford,ford]),is.corr=FALSE,method="color",tl.col=ccol[ford], 
         tl.cex=0.8,col=mycol3[-c(1:2)], mar=c(0,0,1,0),
         p.mat=mp[ford,ford], sig.level=0.05)
title("p-values")
tmp <- as.numeric(table(fchannel))
corrRect(tmp,col=Syncol,lwd=8);rm(tmp)
```
The `X`'s in the above right figure denote a p-value greater than 0.05.

## Scatterplots 

We will run PCA on the untransformed correlation matrix so the data can be 
viewed in 2-dimensions.  The colors correspond to synapse type.

```{r cc-pca1,h=7,w=7,fig.cap=fig$cap("pairs1","PCA of untransformed correlation matrix")}
pca1 <- prcomp(corrf,center=TRUE, scale=TRUE)
pairs(pca1$x[,1:3], col=ccol3,pch=20, cex=2)
```


```{r cc_3dCorr, fig.cap=fig$cap("rgl1","PCA 1-3 on untransformed correlation matrix")}
pca <- pca1$x
rgl::plot3d(pca[,1],pca[,2],pca[,3],type='s',col=ccol3, size=1)
rgl::rgl.texts(pca[,1],pca[,2],pca[,3],abbreviate(channel), col=ccol3, adj=c(0,2))
subid <- currentSubscene3d()
rglwidget(elementId="rgl-pca1",width=720,height=720)
```


```{r cc-lda1}
d1 <- data.frame(type=factor(channel.type[ford]),pca1$x)
try(lda.fit <- lda(type ~ ., data=d1),silent=FALSE)
geterrmessage()
lda.fit <- lda(type ~ ., data=d1[,1:4])
```
<FONT COLOR=#750000> 
LDA was run using only the first 3 out of 24 principal 
components from the untransformed correlation matrix.
</FONT>  

```{r cc-voronoi,h=6,w=14,fig.cap=fig$cap("voronoi","Voronoi diagram on class means from LDA on PCA of untransformed correlation matrix")}
voronoidf <- data.frame(x=lda.fit$means[,1],y=lda.fit$means[,2],z=lda.fit$means[,3])
voronoidf$lab <- rownames(voronoidf)

#This creates the voronoi line segments
voronoiXY <- deldir(voronoidf$x,voronoidf$y)
 
gg1 <- ggplot(data=voronoidf,aes(x=x,y=y)) +
        geom_segment(
            aes(x=x1,y=y1,xend=x2,yend=y2),
            size=1,
            data=voronoiXY$dirsgs,
            linetype=1,
            color="#FFB958") +
#        #Plot the points
        geom_point(
          fill=rgb(70,130,180,255,maxColorValue=255),
          pch=21,
          size = 4,
          color="#333333")

voronoiXZ <- deldir(voronoidf$x,voronoidf$z)
gg2 <- ggplot(data=voronoidf,aes(x=x,y=z)) +
        geom_segment(
            aes(x=x1,y=y1,xend=x2,yend=y2),
            size=1,
            data=voronoiXZ$dirsgs,
            linetype=1,
            color="#FFB958") +
#        #Plot the points
        geom_point(
          fill=rgb(70,130,180,255,maxColorValue=255),
          pch=21,
          size = 4,
          color="#333333")

voronoiYZ <- deldir(voronoidf$y,voronoidf$z)
gg3 <- ggplot(data=voronoidf,aes(x=y,y=z)) +
        geom_segment(
            aes(x=x1,y=y1,xend=x2,yend=y2),
            size=1,
            data=voronoiYZ$dirsgs,
            linetype=1,
            color="#FFB958") +
#        #Plot the points
        geom_point(
          fill=rgb(70,130,180,255,maxColorValue=255),
          pch=21,
          size = 4,
          color="#333333")

layoutM <- matrix(cbind(1,2,3), nrow=1)
grid.arrange(gg1,gg2,gg3, layout_matrix=layoutM)
```

```{r cc-lda3d}
ldam <- lda.fit$means
plot3d(ldam[,1], ldam[,2], ldam[,3])
```










## Top 1% 

### Top Synap_1
```{r cc-top1synap1F0, results='hide'}
top1synap1F0 <- slog1f[Synap_1F0 > quantile(Synap_1F0, 0.99),]
dim(top1synap1F0)

lp1 <- splom(~top1synap1F0,
	panel=panel.hexbinplot, colramp=BTC, 
	diag.panel = function(x, ...){
	 yrng <- current.panel.limits()$ylim
	 d <- density(x, na.rm=TRUE)
	 d$y <- with(d, yrng[1] + 0.95 * diff(yrng) * y / max(y) )
	 panel.lines(d)
	 diag.panel.splom(x, ...)
	 },
	lower.panel = function(x, y, ...){
	 panel.hexbinplot(x, y, ...)
	 panel.loess(x, y, ..., col = 'red')
	 },
	pscale=0,varname.cex=0.9
 )

pdf("../Figures/MarkerExploration_figure/cc-top1synap1F0.pdf",height=25,width=25)
print(lp1)
dev.off()
```

Note that when we select only the top 1% of Synap_1F0 levels we end up with only `r dim(top1synap1F0)[1]` 
observations.  
This plot is too large to show inline, you can view it here:
[F0 Lattice Plot conditioned on top 1% of Synap_1F0](../Figures/MarkerExploration_figure/cc-top1synap1F0.pdf)


### Top gadF0
```{r cc-top1gadF0, results='hide'}
top1gadF0 <- slog1f[gadF0 > quantile(gadF0, 0.99),]
dim(top1gadF0)

lp2 <- splom(~top1gadF0,
	panel=panel.hexbinplot, colramp=BTC, 
	diag.panel = function(x, ...){
	 yrng <- current.panel.limits()$ylim
	 d <- density(x, na.rm=TRUE)
	 d$y <- with(d, yrng[1] + 0.95 * diff(yrng) * y / max(y) )
	 panel.lines(d)
	 diag.panel.splom(x, ...)
	 },
	lower.panel = function(x, y, ...){
	 panel.hexbinplot(x, y, ...)
	 panel.loess(x, y, ..., col = 'red')
	 },
	pscale=0,varname.cex=0.9
 )

pdf("../Figures/MarkerExploration_figure/cc-top1gadF0.pdf",height=25,width=25)
print(lp2)
dev.off()
```

Note that when we select only the top 1% of gadF0 levels we end up with only `r dim(top1gadF0)[1]` 
observations.  
This plot is too large to show inline, you can view it here:
[F0 Lattice Plot conditioned on top 1% of gadF0](../Figures/MarkerExploration_figure/cc-top1gadF0.pdf)



## K-means

Here we run the K-means++ algorithm for $k=2$ on the scaled 
and centered principal components of the correlation matrix.
The algorithm is implemented [here](./kmpp.r).

```{r cc-k1}
kp1 <- kmpp(pca,k=3)
km <- kmeans(pca, centers=3)
ari <- mclust::adjustedRandIndex(kp1$cluster,km$cluster)
if(ari < 1){ print(ari) }
```

```{r cc_3dKMPP}
rgl::plot3d(pca[,1],pca[,2],pca[,3],type='s',col=ccol3, size=kp1$cluster)
rgl::rgl.texts(pca[,1],pca[,2],pca[,3],abbreviate(channel), col=ccol3, adj=c(0,1.5))

subid <- currentSubscene3d()
rglwidget(elementId="plot3dLog", width=720, height=720)
```
Above the points are sized according to the resulting clustering
returned by K-means++.


# ARI
```{r cc_f1, eval=TRUE, echo=FALSE}
avd <- function(pcaObj,elbow,truth,K){
###
### Given a pca object with an elbow as upper-bound
### compute the ARI of truth versus the kmeans clustering for each
### dimension from 1:elbow.  Also compute a permutation test for the ARI
### for each dimension from 1:elbow
###
require(foreach)

MAX <- 1e3

kv <- foreach(i = 1:elbow) %do% {
        set.seed(i*3 +2)
        ### kvec for ith dimension of PCA
        k <- as.numeric(kmeans(pcaObj$x[,1:i],centers=K)$cluster)

        ## ari of clustering vs truth
        ari <- mclust::adjustedRandIndex(truth,k)
        list(k=k,ari=ari)
        }

out <- foreach(i = 1:elbow,.combine='rbind') %:% 
       foreach(j = 1:MAX,.combine='rbind') %do% {
           set.seed(j*3 + 1)
           ### Calculate the permutation
           y <- sample(kv[[i]]$k) 

           ##E gets ari of permutation vs truth
           data.frame(Embedding_Dimension=i,permARI=mclust::adjustedRandIndex(truth,y))
           }

out$Embedding_Dimension <- as.factor(out$Embedding_Dimension)

clusterARI <- sapply(kv,'[[',2)

out$ari <- rep(clusterARI, each=MAX)
#L <- list(distARI=out,ari=clusterARI)

return(out)
}

```

Here we consider the channel types to be the "ground truth" and computer
the Adjusted Rand Index of between that and the output from k-means.


## Approximate permutation test.
```{r cc_truth}
levels(ffchannel) <- c(rep("ex", 2), rep("in", 2), rep("other", 3))
levels(ffchannel)
truth <- as.numeric(ffchannel)
```

```{r arislog1f,eval=FALSE,echo=FALSE}
kcl <- kmpp(corLog,k=3)
kcl <- as.numeric(kcl$cluster) 
v1 <- mclust::adjustedRandIndex(truth,kcl)

ariCor <- foreach(j=1:1e5,.combine='c') %dopar%{
    set.seed(j*2^8-3)  # for reproducibility 
    y <- sample(kcl)
    mclust::adjustedRandIndex(truth,y)
    }

N <- length(ariCor)
(pval <- sum(ariCor >= v1)/N)
```

```{r cc_ariPlots,eval=FALSE,echo=FALSE,w=4,h=4, fig.cap=fig$cap("ariPlot","ARI plot")}
h1 <- hist(ariCor,xlim=c(min(ariCor),v1+v1/2), prob=TRUE, breaks='Sc',plot=TRUE,main=NULL, xlab="ARI")
title("Approx. permutation test.")
abline(v = v1, lwd=2, col='darkred')
text(median(h1$breaks),quantile(h1$density,.98),col='darkred',labels=mtext(bquote(hat(p)==.(pval))))
```

```{r cc-pca, eval=TRUE}
pca <- prcomp(corrf,scale=TRUE, center=TRUE)
elb <- getElbows(pca$sdev, plot=TRUE) 
pcaLog <- prcomp(corLog,scale=TRUE, center=TRUE)
elLog <- getElbows(pcaLog$sdev, plot=TRUE) 
```

Making a data.table of the permutation data for ggplot.
```{r cc-ariVdim}
DT <- data.table(avd(pcaLog,elLog[2],truth,3),key='Embedding_Dimension') 



DT <- DT[,pval := sum(permARI>=ari)/length(permARI),by=Embedding_Dimension]

ua <- DT[,unique(ari),by=Embedding_Dimension]
arid <- data.frame(Embedding_Dimension=as.numeric(ua$Emb),
                   ARI=ua$V1,
                   pval=DT[,unique(pval),by=Embedding_Dimension]$V1)
```

```{r cc-gg3, w=20,h=12, fig.cap=fig$cap("ariPerm","ARI Permutation Tests")}
gg3 <- ggplot(data=DT,aes(x=permARI, y=..density..,color=Embedding_Dimension,label=pval)) + 
        #geom_histogram(binwidth=3.49*sd(DT$permARI)*length(DT$permARI)^(-1/3)) +
        geom_histogram(bins=25)+
        geom_vline(aes(xintercept=ari),colour='darkred',size=1.2)+
        #geom_text(aes(x=(ari-ari/2),y=7))+
        theme(axis.text=element_text(size=18),
                  title=element_text(size=16),  
                  strip.text.x=element_text(size=16)) + 
        facet_wrap(~Embedding_Dimension+pval,scale='free',labeller=label_both)
print(gg3)
```

```{r arivDim, w=12,h=8, fig.cap=fig$cap("ari_pvals","ARI and P-Values")}
gg5 <- ggplot(data=arid,aes(x=Embedding_Dimension,y=ARI,label=pval,colour=pval)) + 
        geom_line(size=1.5,colour='salmon') + geom_point(size=3) +
            #geom_text(hjust='right',vjust='top',nudge_x=0.5,nudge_y=0.01,size=5)+
            theme(axis.text=element_text(size=18),
                  title=element_text(size=16)) + 
            ggtitle("ARI vs. DIM with estimated p-values")

gg6 <- 
    ggplot(data=arid, aes(x=Embedding_Dimension, y=pval, colour=pval))+
        geom_line(size=1.5, colour='salmon') + 
        geom_point(size=3) + 
       # geom_hline(yintercept=0.05, 
       #            colour='forestgreen',
       #            size=1.5) +
        scale_y_log10(breaks=c(1e-4,1.53-4,1e-3), na.value=0) +
        theme(axis.text=element_text(size=18),
                  title=element_text(size=16)) + 
        ggtitle("P-values")

grid.arrange(gg5,gg6,nrow=2)
```

# `GABABR`

```{r cc-latPrep}
## re-formatting data for use in lattice 
d1gab <- data.table(stack(fs, select=-GABABRF0))[,.(values)]
d1gab$GABABR <- fs$GABABRF0

### Adding relationship factor variables
nd <- paste0("GABABR","~",abbreviate(channel[-which(channel=="GABABR")]))

d1gab$ind <- factor(rep(nd,each=dim(fs)[1]),ordered=TRUE,levels=nd)

names(d1gab) <- c("x","y","g")
```

```{r cc-gabLat, eval=FALSE, echo=FALSE}
## re-formatting data for use in lattice 
d1gab <- data.table(stack(fs, select=-GABABRF0))[,.(values)]
d1gab$GABABR <- fs$GABABRF0

### Adding relationship factor variables
nd <- paste0("GABABR","~",abbreviate(channel[-which(channel=="GABABR")]))

d1gab$ind <- factor(rep(nd,each=dim(fs)[1]),ordered=TRUE,levels=nd)

names(d1gab) <- c("x","y","g")

lat1 <- xyplot(y ~ x | g, data=d1gab,
       as.table=TRUE,
       colramp=BTC,
       pch='.',
       scales = list(y = list(relation = "free"),x = list(relation = "free")),
       panel=function(x,y,...){
           panel.hexbinplot(x,y,..., type='g')
           panel.loess(x,y,col='red', lwd=2,...)
        }
       )
```

```{r cc-lat1,eval=FALSE,echo=FALSE,w=10,h=10,fig.cap=fig$cap("rg1", "Lattice plot of pairwise regressions involving `GABABR`")}
print(lat1)
```


```{r cc-gabGG}
gg7 <- ggplot(data=d1gab,aes(x=x,y=y, group=g)) +   
        geom_point(pch='.',alpha=0.2) + 
        geom_hex(bins=100) +
        geom_smooth(method='lm',colour='red', alpha=0.7)+
        facet_wrap( ~ g, scales='free_x') 
```

```{r cc-gg5,w=8,h=8,fig.cap=fig$cap("gabLat", "Pairs plots of GABABR and all other markers with regression lines.")}
print(gg7)
```

<footer>
<p> [Back to Top][Data]</p>
</footer>
