---
title: "Synapse Stats: Synapse Exploration"
author: "JLP"
date: '`r Sys.Date()`'
output:
  html_document:
    fig_caption: yes
    fig_height: 5
    fig_width: 5
    highlight: pygments
    keep_md: yes
    number_sections: yes
    theme: cerulean
    toc: yes
    toc_depth: 3
  pdf_document:
    fig_caption: yes
    keep_tex: yes
    number_sections: yes
---
```{r render, eval=FALSE, echo=FALSE}
require(rmarkdown)
rm(list=ls()); 
rmarkdown::render(grep("SynapseExploration.Rmd", dir(), value=TRUE))
system('open SynapseExploration.html')
```
```{r setup,include=FALSE,results='asis',message=FALSE,warning=FALSE}
### Library calls here.
require(Matrix)
require(colorRamps)
require(hexbin)
require(corrplot)
require(gplots)
require(dplyr)
require(reshape2)
require(ggplot2)
require(gridExtra)
require(lattice)
require(parallel)
require(data.table)
require(fpc)
require(repr)
require(mclust)
require(doMC)
require(rgl)
require(rglwidget)

source("./bic.r")
source("./clusterFraction.r")
source("./kmpp.r")
#source("./getElbows.r")
source("http://www.cis.jhu.edu/~parky/Synapse/getElbows.R")
registerDoMC(6)

library(rmarkdown)
library(knitr)
```
```{r knitr-setup, include=FALSE, results='asis'}
### The following options and figure numbering functions
### were setup by Youngser Park
knitr::opts_chunk$set(cache=TRUE, autodep=TRUE)
dep_auto() # figure out dependencies automatically
opts_chunk$set(cache=FALSE,echo=TRUE,warning=FALSE,message=FALSE,comment="#",fig.path='../Figures/SynapseExploration_figure/',dpi=227,dev=c('png','pdf'))

opts_knit$set(aliases=c(h='fig.height', w='fig.width', cap='fig.cap', scap='fig.scap'))                                                                               
opts_knit$set(eval.after = c('fig.cap','fig.scap'))                                                                            
knit_hooks$set(document = function(x) {
  gsub('(\\\\end\\{knitrout\\}[\n]+)', '\\1\\\\noindent ', x)                                                   })
#opts_knit$set(animation.fun = hook_scianimator)

knit_hooks$set(plot = function(x, options) {
       paste('<figure><img src="',
             opts_knit$get('base.url'), paste(x, collapse = '.'),
             '"><figcaption>', options$fig.cap, '</figcaption></figure>',
             sep = '')
 })
 
 fn = local({
   i = 0
   function(x) {
     i <<- i + 1
     paste('Figure ', i, ': ', x, sep = '')
   }
 })

 fig <- local({
    i <- 0
    ref <- list()
    list(
        cap=function(refName, text) {
            i <<- i + 1
            ref[[refName]] <<- i
            paste("<b>Figure ", i, ": ", text, "</b><br><br>", sep="")
        },
        ref=function(refName) {
            ref[[refName]]
        })
})
```

[Homepage](http://docs.neurodata.io/synaptome-stats/)  
The formatted source code for this file is [here](https://github.com/neurodata/synaptome-stats/blob/gh-pages/Code/SynapseExploration.Rmd).  
And a [raw version here](https://raw.githubusercontent.com/neurodata/synaptome-stats/gh-pages/Code/SynapseExploration.Rmd).    
Previous work by Youngser Park can be found [here](http://www.cis.jhu.edu/~parky/Synapse/synapse.html).  


# Introduction

Following from previous pages, this page will focus on filtering the data before clustering 
to explore if filtering improves the outcome of clustering.

# Data 
Here we read in the data and select a random half of it for exploration. 

```{r cc-data, eval=TRUE}
featFull <- fread("../data/synapsinR_7thA.tif.Pivots.txt.2011Features.txt",showProgress=FALSE)
locFull <- fread("../data/synapsinR_7thA.tif.Pivots.txt",showProgress=FALSE)

### Setting a seed and creating an index vector
### to select half of the data
set.seed(2^10)
half1 <- sample(dim(featFull)[1],dim(featFull)[1]/2)
half2 <- setdiff(1:dim(featFull)[1],half1)

feat <- featFull[half1,]
loc <- locFull[half1,]
dim(feat)

## Setting the channel names
channel <- c('Synap_1','Synap_2','VGlut1_t1','VGlut1_t2','VGlut2','Vglut3',
              'psd','glur2','nmdar1','nr2b','gad','VGAT',
              'PV','Gephyr','GABAR1','GABABR','CR1','5HT1A',
              'NOS','TH','VACht','Synapo','tubuli','DAPI')

## Setting the channel types
channel.type <- c('ex.pre','ex.pre','ex.pre','ex.pre','ex.pre','in.pre.small',
                  'ex.post','ex.post','ex.post','ex.post','in.pre','in.pre',
                  'in.pre','in.post','in.post','in.post','in.pre.small','other',
                  'ex.post','other','other','ex.post','none','none')

nchannel <- length(channel)
nfeat <- ncol(feat) / nchannel

## Createing factor variables for channel and channel type sorted properly
ffchannel <- (factor(channel.type,
    levels= c("ex.pre","ex.post","in.pre","in.post","in.pre.small","other","none")
    ))
fchannel <- as.numeric(factor(channel.type,
    levels= c("ex.pre","ex.post","in.pre","in.post","in.pre.small","other","none")
    ))
ford <- order(fchannel)


## Setting up colors for channel types
Syncol <- c("#197300","#5ed155","#660000","#cc0000","#ff9933","mediumblue","gold")
ccol <- Syncol[fchannel]

exType <- factor(c(rep("ex",11),rep("in",6),rep("other",7)),ordered=TRUE)
exCol<-exType;levels(exCol) <- c("#197300","#990000","mediumblue");
exCol <- as.character(exCol)

fname <- as.vector(sapply(channel,function(x) paste0(x,paste0("F",0:5))))
names(feat) <- fname
fcol <- rep(ccol, each=6)
mycol <- colorpanel(100, "purple", "black", "green")
mycol2 <- matlab.like(nchannel)
```

## Data transformations

```{r cc-datatrans, eval=TRUE}
f <- lapply(1:6,function(x){seq(x,ncol(feat),by=nfeat)})
featF <- lapply(f,function(x){subset(feat,select=x)})

featF0 <- featF[[1]]
f01e3 <- 1e3*data.table(apply(X=featF0, 2, function(x){((x-min(x))/(max(x)-min(x)))}))

fs <- f01e3

### Taking log_10 on data with 0's removed
ans <- apply(featF0, 1, function(row){ any(row == 0)})

logF0 <- log10(featF0[!ans,])
slogF0 <- logF0[,lapply(.SD,scale, center=TRUE,scale=TRUE)]
```

We now have the following data sets:

- `featF0`: The feature vector looking only at the integrated brightness features.
- `fs`:  The feature vector scaled between $[0,1000]$.
- `logF0`: The feature vector, with 0's removed, then $log_{10}$ is applied. 
- `slogF0`: The feature vector, with 0's removed, then $log_{10}$, then scaled by
  subtracting the mean and dividing by the sample standard deviation.


# Synapse Exploration

### Kernel Density Estimates of the marginals

```{r synEx-kde1, eval=TRUE,echo=TRUE,cache=FALSE,w=18,h=12,fig.cap=fig$cap("synEx-kde1","Kernel density estimates for each channel, on `fs` data.")}
df1 <- melt(as.matrix(fs))
names(df1) <- c("ind","channel","value")
df1$type <- factor(rep(ffchannel,each=dim(fs)[1]),levels=levels(ffchannel))

lvo <- c(1:5,7:10,19,22,11:16,6,17,18,20,21,23,24)
levels(df1$channel)<-levels(df1$channel)[lvo]

ts <- 22

gg1 <- ggplot(df1, aes(x=value)) + 
    scale_color_manual(values=ccol[lvo]) +
    scale_fill_manual(values=ccol[lvo]) +
    geom_histogram(aes(y=..density..,group=channel,colour=channel),bins=100) +
    geom_density(aes(group=channel, color=channel),size=1.5) +
    facet_wrap( ~ channel, scale='free', ncol=6) +
    theme(plot.title=element_text(size=ts),
          axis.title.x=element_text(size=ts),
          axis.title.y=element_text(size=ts),
          legend.title=element_text(size=ts),
          legend.text=element_text(size=ts-2),
          axis.text=element_text(size=ts-2),
          strip.text=element_text(size=ts), 
          legend.position='none')+
    ggtitle("Kernel Density Estimates of `fs` data.")

print(gg1)
```

## Correlations

```{r cc_cor,w=5,h=5, eval=TRUE,fig.cap=fig$cap("cor","Correlation on untransformed F0 data, reordered by synapse type.")}
cmatfs <- cor(fs)
corrplot(cmatfs,method="color",tl.col=ccol[ford], tl.cex=1.8)
```
### PCA on the Correlation Matrix

```{r pcaLog, eval=TRUE}
pcaf0 <- prcomp(featF0,scale=TRUE, center=TRUE)
pcafs <- prcomp(fs,scale=FALSE, center=FALSE)
elpcaf0 <- getElbows(pcaf0$sdev, plot=FALSE)
elpcafs <- getElbows(pcafs$sdev, plot=FALSE)
```

## K-means++ for $K=2$ (Level 1).
We run K-means++ for $K=2$ on the `fs` data.

```{r cc-k1,eval=TRUE,echo=TRUE}
K1 <- c(2)  ## The set of K's.

set.seed(2^13)
k0 <- kmpp(logF0, k=2)
kl <- list()
kl[[1]] <- list(c1 = k0$cluster == 1,c2 = k0$cluster==2)
```

### Within cluster correlations

```{r cc-wcc1, h=8,w=8,fig.cap=fig$cap("corkp1","Within cluster correlations, clock-wise from top left, Cluster 1, Cluster 2, l2 distance between C1 and C2")}
corkp1 <- cor(fs[kl[[1]]$c1,])
corkp2 <- cor(fs[kl[[1]]$c2,])

par(mfrow=c(2,2))
corrplot(corkp1,method="color",tl.col=ccol[ford], tl.cex=0.8)
corrplot(corkp2,method="color",tl.col=ccol[ford], tl.cex=0.8)
corrplot(sqrt((corkp1 - corkp2)^2),method="color",tl.col=ccol[ford], tl.cex=0.8)
```

Notice that the non-synaptic markers change very little between
clusters.  Also note that the correlations between (`gad, VGAT, PV,
Gephyr`) and `VGlut1` at both times change significantly between
clusters.

### Heat maps:

```{r cc_agg, eval=TRUE}
## Formatting data for heatmap
aggp <- aggregate(fs,by=list(lab=klist[[1]]$cluster),FUN=mean) # FIX THIS
aggp <- as.matrix(aggp[,-1])
rownames(aggp) <- clusterFraction(klist[[1]])
```

The following are heatmaps generated from clustering 
via K-means++

```{r cc-kmpp-heatmap,eval=FALSE,echo=FALSE,w=6,h=6,fig.cap=fig$cap("heat1", "Heatmap of the cluster means vs channels. Rows and columns are rearranged according to hclust.")}
heatmap.2(as.matrix(aggp), trace="none",col=mycol,colCol=ccol,cexRow=0.8, keysize=1,symkey=FALSE,symbreaks=FALSE,scale="none", srtCol=90,main="Heatmap of `fs` data") # 
```

```{r cc-kmpp-heatmapSorted,eval=TRUE,w=6,h=6,fig.cap=fig$cap("heatfs1", "Heatmap of the cluster means vs channels. Rows and columns are rearranged according to synapse type.")}
heatmap.2(as.matrix(aggp),dendrogram='row',Colv=NA,trace="none", col=mycol,colCol=ccol[ford],cexRow=0.8, keysize=1.25,symkey=FALSE,symbreaks=FALSE,scale="none", srtCol=90,main="Heatmap of `fs` data.") 
```

Percentage of data within cluster is presented on the right side of the heatmap.



### Kernel Density Estimates of the marginals | cluster 

Here we look at the kernel density estimates within each cluster to
compare.

```{r synEx-kde1c2prep}
df2 <- melt(as.matrix(fs))
names(df2) <- c("ind","channel","value")
df2$cluster <- klist[[1]]$cluster
df2$type <- factor(rep(ffchannel,each=dim(fs)[1]),levels=levels(ffchannel))

gg2 <- ggplot(df2, aes(x=value)) + 
    scale_colour_manual(values=ccol) + 
    scale_x_continuous(limits=c(0,400)) +
    geom_histogram(aes(y=..density..,group=channel,colour=channel),bins=250) +
    geom_density(aes(group=channel, color=channel),size=1.5) +
    facet_grid(channel ~ cluster, scale='free') + 
    theme(strip.text.y=element_text(angle=0)) +
    guides(col=guide_legend(ncol=1))
```

```{r synEx-kde1c2, eval=TRUE,echo=TRUE,cache=FALSE,w=12,h=18,fig.cap=fig$cap("gKDE","Kernel density estimates for each channel, on `fs` data given cluster from km++")}
print(gg2)
```

### Clusters and Spatial Location
Using the location data and the results of K-means++ we show a 3d scatter
plot colored accoding to cluster.

```{r cc-kpp3d}
set.seed(2^12)
s1 <- sample(dim(loc)[1],5e4)

locs1 <- loc[s1,]
locs1$cluster <- klist[[1]]$cluster[s1]

plot3d(locs1$V1,locs1$V2,locs1$V3,
       col=ifelse(locs1$cluster==1,'#d95f02','#6a3d9a'), #orange,purple
       alpha=0.75,
       xlab='x', 
       ylab='y', 
       zlab='z')

subid <- currentSubscene3d()
rglwidget(elementId="plot3dLocations")
```

## `GABABR`

```{r cc-gabLat}
## re-formatting data for use in lattice 
d1gab <- data.table(stack(fs, select=-GABABRF0))[,.(values)]
d1gab$GABABR <- fs$GABABRF0

### Adding relationship factor variables
nd <- paste0("GABABR","~",abbreviate(channel[-which(channel=="GABABR")]))

d1gab$ind <- factor(rep(nd,each=dim(fs)[1]),ordered=TRUE,levels=nd)

names(d1gab) <- c("x","y","g")

lat1 <- xyplot(y ~ x | g, data=d1gab,
       as.table=TRUE,
       colramp=BTC,
       pch='.',
       scales = list(y = list(relation = "free"),x = list(relation = "free")),
       panel=function(x,y,...){
           panel.hexbinplot(x,y,..., type='g')
           panel.loess(x,y,col='red', lwd=2,...)
        }
       )
```

```{r cc-lat1,eval=FALSE,echo=FALSE,w=10,h=10,fig.cap=fig$cap("rg1", "Lattice plot of pairwise regressions involving `GABABR`")}
print(lat1)
```


```{r cc-gabGG}
gg3 <- ggplot(data=d1gab,aes(x=x,y=y, group=g)) +   
        geom_point(pch='.',alpha=0.2) + 
        geom_hex(bins=100) +
        geom_smooth(method='lm',colour='red', alpha=0.7)+
        facet_wrap( ~ g, scales='free_x') 
```

```{r cc-gg3,w=8,h=8,fig.cap=fig$cap("gabLat","Pairs plots of GABABR and all other markers with regression lines.")}
print(gg3)
```



## K-means++ for $K=2$ (Level 2).

We run the next level of K-means++ for $K=2$ on the `fs` data.


```{r cc-k2,eval=TRUE,echo=TRUE}
###
###
### Naming convention: 
###     k<numeric> := kmpp on the <numeric>th node
###         in the tree as read in a binary tree 
###
###     c<numeric> := the logical vector of class membership for 
###         <numeric>th cluster.
###      
K2 <- c(2)  ## The set of K's.

set.seed(2^13)
k1 <-kmpp(logF0[kl[[1]]$c1,], k = K2)
set.seed(2^13)
k2 <-kmpp(logF0[kl[[1]]$c2,], k = K2)
kl[[2]] <- list(c11 = k1$cluster == 1, c12 = k1$cluster==2, 
                c21 = k2$cluster == 1, c22 = k2$cluster==2)
```

### Within cluster correlations

```{r cc-wcc2,h=8,w=14,fig.cap=fig$cap("corkp2","Within cluster correlations for level 2. (c11, c12, c21, c22)")}
corkp11 <- cor(featF0[kl[[1]]$c1,][kl[[2]]$c11,])
corkp12 <- cor(featF0[kl[[1]]$c1,][kl[[2]]$c12,])
corkp21 <- cor(featF0[kl[[1]]$c2,][kl[[2]]$c21,])
corkp22 <- cor(featF0[kl[[1]]$c2,][kl[[2]]$c22,])

par(mfrow=c(1,4))
corrplot(corkp11,method="color",tl.col=ccol[ford], tl.cex=0.8)
corrplot(corkp12,method="color",tl.col=ccol[ford], tl.cex=0.8)
corrplot(corkp21,method="color",tl.col=ccol[ford], tl.cex=0.8)
corrplot(corkp22,method="color",tl.col=ccol[ford], tl.cex=0.8)
```


### Heat maps (level 2):

```{r cc_agg, eval=TRUE}
## Formatting data for heatmap
labs2 <- c(k1$cluster,k2$cluster+2)
aggp2 <- aggregate(logF0,by=list(lab=labs2),FUN=function(x){mean(x)}) # FIX THIS
aggp2 <- as.matrix(aggp2[,-1])
rownames(aggp2) <- clusterFraction(labs2)
```

The following are heatmaps generated from clustering 
via K-means++

```{r cc-kmpp-heatmap,eval=FALSE,echo=FALSE,w=6,h=6,fig.cap=fig$cap("heat1", "Heatmap of the cluster means vs channels. Rows and columns are rearranged according to hclust.")}
heatmap.2(as.matrix(aggp2), trace="none",col=mycol,colCol=ccol,cexRow=0.8, keysize=1,symkey=FALSE,symbreaks=FALSE,scale="none", srtCol=90,main="Heatmap of `fs` data") # 
```

```{r cc-kmpp-heatmapSorted,eval=TRUE,w=6,h=6,fig.cap=fig$cap("heatfs1", "Heatmap of the cluster means vs channels. Rows and columns are rearranged according to synapse type.")}
heatmap.2(as.matrix(aggp2),dendrogram='row',Colv=NA,trace="none", col=mycol,colCol=ccol[ford],cexRow=0.8, keysize=1.25,symkey=FALSE,symbreaks=FALSE,scale="none", srtCol=90,main="Heatmap of `fs` data.") 
```

Percentage of data within cluster is presented on the right side of the heatmap.



### Kernel Density Estimates of the marginals | cluster 

Here we look at the kernel density estimates within each cluster to
compare.

```{r synEx-kde1c2prep}
df2 <- melt(as.matrix(logF0))
names(df2) <- c("ind","channel","value")
df2$cluster <- labs2
df2$type <- factor(rep(ffchannel,each=dim(logF0)[1]),levels=levels(ffchannel))

s8 <- sample(dim(df2)[1],1e5)
dft <- df2[s8,]


gg2 <- ggplot(dft, aes(x=value)) + 
    scale_colour_manual(values=ccol) + 
    #scale_x_continuous(limits=c(0,400)) +
    geom_histogram(aes(y=..density..,group=channel,colour=channel),bins=250) +
    #geom_density(aes(group=channel, color=channel),size=1.5) +
    facet_grid(channel ~ cluster, scale='free') + 
    theme(strip.text.y=element_text(angle=0)) +
    guides(col=guide_legend(ncol=1))
print(gg2)
```

```{r synEx-kde1c2, eval=TRUE,echo=TRUE,cache=FALSE,w=12,h=18,fig.cap=fig$cap("gKDE","Kernel density estimates for each channel, on `fs` data given cluster from km++")}
print(gg2)
```

### Clusters and Spatial Location
Using the location data and the results of K-means++ we show a 3d scatter
plot colored accoding to cluster.

```{r cc-kpp3d}
set.seed(2^12)
s1 <- sample(dim(loc)[1],5e4)

locs1 <- loc[s1,]
locs1$cluster <- klist[[1]]$cluster[s1]

plot3d(locs1$V1,locs1$V2,locs1$V3,
       col=ifelse(locs1$cluster==1,'#d95f02','#6a3d9a'), #orange,purple
       alpha=0.75,
       xlab='x', 
       ylab='y', 
       zlab='z')

subid <- currentSubscene3d()
rglwidget(elementId="plot3dLocations")
```




<footer>
<p> [Back to top][Introduction]</p>
</footer>
