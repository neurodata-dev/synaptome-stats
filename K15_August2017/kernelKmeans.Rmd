---
title: "Kernel K-means on K15 synapse data"
author: "Jesse Leigh Patsolic"
output: 
  html_document:
    keep_md: true
---

```{r render, eval=FALSE, echo=FALSE}
rm(list = ls())
require(rmarkdown)
rmarkdown::render("kernelKmeans.Rmd")
system('open kernelKmeans.html')
```

```{r setup}
require(RMySQL)
require(data.table)
require(raster)
require(meda)
require(rgl)
require(viridis)
require(lattice)
require(rglwidget)
require(irlba)
require(MGC)
require(fmriutils)
require(plotly)
require(knor)
require(heatmaply)
require(gplots)
```

## Data Preparation 

```{r connect}
## Set up the connection to the database.
## REMEMBER to disconnect when finished.

con0 <- file("mysqlPassword.txt", "r")
pswd <- readLines(con0, n = 1)
con1  <- dbConnect(MySQL(), user="root", dbname="synapses",
                   password=pswd);dbSendQuery(con1, "SET NAMES 'UTF8';")

q1 <- c("SELECT * FROM kristina15")
suppressWarnings(dat0 <- data.table(dbGetQuery(con1, q1)))
dbDisconnect(con1)
```

```{r subsamp}
chan <- c('synapsinR_7thA','synapsinGP_5thA','VGluT1_3rdA','VGluT1_8thA',
					'VGluT2_2ndA', 'psd_8thA', 'GluR2_2ndA', 'NMDAR1_6thA',
					'NR2B_9thA','NOS_9thA', 'Synpod_3rdA', 'GAD_6thA','VGAT_5thA', 
					'PV_1stA','gephyrin_1stA', 'GABARa1_4thA', 'GABABR1_3rdA',
					'VGluT3_1stA', 'CR1_2ndA','5HT1A_6th', 'TH_5thA','VAChT_4thA',	
          'tubulin_8thA', 'dapi_1stA')

Syncol3 <- c("#197300","#cc0000","#0000cd")

ccol <- Syncol3[c(rep(1,11), rep(2,6), rep(3,7))]

dat0 <- dat0[, c("x", "y", "z", chan), with = FALSE]
setkey(dat0, x,y,z)

xyz <- dat0[, .(x,y,z)]
dat <- dat0[, !(x:z)]

if(!file.exists("sample_locations_1e4.csv")){
  print("Selecting sample locations")
  
  set.seed(317)
  samp10k <- sample(nrow(dat), 1e4)
  write.csv(xyz[samp10k], file = "sample_locations_1e4.csv", row.names = FALSE)

  set.seed(1030)
  samp1k <- sample(nrow(dat), 1e3)
  write.csv(xyz[samp1k], file = "sample_locations_1e3.csv", row.names = FALSE)
} else {
  samp10k <- read.csv("sample_locations_1e4.csv", header=TRUE)
  samp1k  <- read.csv("sample_locations_1e3.csv", header=TRUE)
}


d1ko  <- dat0[samp1k, !(x:z)]
d10ko <- dat0[samp10k, !(x:z)]

d1k  <- d1ko[, lapply(.SD, scale, center=TRUE, scale=TRUE)]
d10k <- d10ko[, lapply(.SD, scale, center=TRUE, scale=TRUE)]
```


```{r kernel1k}
system.time({
svd1k <-svd(as.matrix(d1k)) #svd(d10k)
AAT <- svd1k$u %*% diag(svd1k$d) %*% t(diag(svd1k$d)) %*% t(svd1k$u)
})

Ei <- eigen(AAT)

C <- Ei$vectors
D <- diag(Ei$values)
el <- getElbows(Ei$values)[2]

d <- D[1:el,1:el]

E <- C[,1:el] %*% D[1:el,1:el]^(1/2)
EE <- C %*% D^(1/2)
```

```{r kmeans}
set.seed(1432)
kv <- kmeans(E, centers=kmpp(E, k = 14))
kvbh <- bhkmpp(E, 3)
#cols <- rainbow(4*max(kv$cluster))[4*kv$cluster]
cols <- viridis(4*max(kvbh$L[,3]))[4*kvbh$L[,3]]
cols <- rainbow(4*max(kvbh$L[,3]))[4*kvbh$L[,3]]

plot3d(E, col = cols, pch = 19)
title3d(main = "Results of kernel kmeans")
rglwidget(elementId="plot3d", width = 720, height = 720)
```

```{r pairs, fig.width = 12, fig.height=12}
pairs(E, col = cols, pch = 19, cex = 0.5, main = "pairs plot of embedding to second elbow")
```

## Results of kernel kmeans plotted in first 3 dimensions of original feature space

```{r pairs2}
plot3d(d1k, col = cols, pch = 19, cex = 0.5)
rglwidget(elementId="plot3d2", width = 720, height = 720)
```

```{r pairs3, fig.height = 12, fig.width=12}
pairs(d1k[, 1:8], col = cols, pch = 19, cex = 0.5, main = "results in original feature space using first 8 features")
```



```{r knor}
km <- Kmeans(as.matrix(dat), centers = 100, iter.max=0, init="kmeanspp")
colnames(km$centers) <- chan
heatmap(km$centers, col = viridis(255), main = 'heatmap with 100 points chosen with km++ init')
```

## Hiarachical GMM

```{r hgmm}
h <- hmc(d1k, maxDepth = 3, maxDim = 12, modelNames = "VVV")
plot(h, maxd = 8)
```



# Discriminability of clusters

```{r discriminability}
ord <- order(kvbh$L[,3])
ordb <- order(kv$cluster)
ordgmm <- order(h$dat$labels$col)

dord <- AAT[ord,ord]
dordb <- AAT[ordb,ordb]
dordgmm <- AAT[ordgmm,ordgmm]

p1 <- fmriu.plot.plot_graph(as.matrix(dord), limits = c(min(dord), max(dord)))
p1b <- fmriu.plot.plot_graph(as.matrix(dordb), limits = c(min(dordb), max(dordb)))
p1gmm <- fmriu.plot.plot_graph(as.matrix(dordgmm), limits = c(min(dordgmm), max(dordgmm)))


p1
p1b
p1gmm

D <- discr.distance(dord)
Db <- discr.distance(dordb)
Dggm <- discr.distance(dordggm)

p2 <- fmriu.plot.plot_graph(D, limits=c(min(D), max(D)))
p2b <- fmriu.plot.plot_graph(Db, limits=c(min(Db), max(Db)))
p2gmm <- fmriu.plot.plot_graph(Dgmm, limits=c(min(Dgmm), max(Dgmm)))

p2
p2b
p2gmm

discr.discr(D, kvbh$L[ord,3] , verbose = TRUE)
discr.discr(Db, kv$cluster[ordb] , verbose = TRUE)
discr.discr(Dgmm, h$dat$labels$col[dordgmm] , verbose = TRUE)
```
