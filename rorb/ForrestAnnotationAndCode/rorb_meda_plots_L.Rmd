---
title: "RORB Data: "
date: '`r Sys.Date()`'
output:
  html_document:
    fig_caption: yes
    fig_height: 8
    fig_width: 8
    highlight: pygments
    number_sections: yes
    theme: cerulean
    toc: yes
    toc_depth: 2
---
```{r knitOPTS, include=FALSE}
knitr::opts_chunk$set(cache = FALSE, dev = "png")
```

```{r render, eval=FALSE, echo=FALSE}
require(rmarkdown)
require(knitr)
rmarkdown::render("rorb_meda_plots_L.Rmd")
system("open rorb_meda_plots_L.html -a /Applications/Chrome.app")
```

```{r setup,include=FALSE,results='asis',message=FALSE,warning=FALSE, echo = FALSE}
# Library calls here.
require(rmarkdown)
require(knitr)
require(doMC)
require(foreach)
require(scales)
require(kernlab)
require(dimRed)
require(randomForest)
require(mvtnorm)
require(class)
registerDoMC(4)
suppressMessages(require(meda))
```


# Synapse data

We start with observations of 793 synapses with 12 measurments formatted as a 793x12
matrix. The matrix is Z-scored column-wise and plotted in a pairs plot
colored according to the labels given by the field expert. 

```{r, eval = TRUE, echo = TRUE, include = TRUE}
dat <- read.csv("rorb_gaussianAvg_at.csv")
loc <- read.csv("rorb_gaussianAvg_at_orderLocations.csv")
gabaID <- read.csv("rorb_gaba.csv")
truth <- gaba <- gabaID$gaba

ccol <- c('blue', 'blue', 'blue', 'red', 'red', 'red', 'green', 'black', 'green', 'green', 'black', 'green')
ind <- order(ccol)
ccol <- sort(ccol)

dat <- dat[,ind]
sdat <- as.data.frame(scale(dat, center = TRUE, scale = TRUE))
pairs(sdat, col = gaba + 1, pch = 20, cex = 0.2,
main = "Pairs plot colored by true class")
```


## ZG: Get Elbows

We run the Z-scored data through PCA and plot the scree-plot wiht the
elbows as given by Zhu and Ghodsi. 

```{r pca}
pc1 <- princomp(sdat)
getElbows(pc1$sdev)
pairs(pc1$scores, col = gaba +1, pch = 20, cex = 0.5)
```

## LDA and QDA

Next applying LDA and QDA by increasing the number of principal
components by one. 
```{r lda}
ldaL <- 
  lapply(1:12, 
         function(x){
           ldatmp <- lda(gaba ~ pc1$scores[, 1:x], CV = FALSE)
           predict(ldatmp)
         })

qdaL <- 
  lapply(1:12, 
         function(x){
           qdatmp <- qda(gaba ~ pc1$scores[, 1:x], CV = FALSE)
           predict(qdatmp)
         })

ll <- sapply(lapply(ldaL, '[[', 1), function(x) sum(x != gaba)/length(gaba))
ql <- sapply(lapply(qdaL, '[[', 1), function(x) sum(x != gaba)/length(gaba))

plot(x = 1:12, y = seq(0,0.12,length = 12), type = 'n', xlab = expression(hat(d)), ylab = "L")
points(ll, type = 'b', col = 'blue')
points(ql, type = 'b', col = 'darkred')
text(10,max(ql), label = "qda", col = 'darkred')
text(10, min(ll), label = "lda", col = 'blue', pos = 1)

qmm <- sapply(1:12, function(x) sum((gaba - qdaL[[x]]$post[, 1])^2))
lmm <- sapply(1:12, function(x) sum((gaba - ldaL[[x]]$post[, 1])^2))

plot(qmm,  type = 'b', col = 'blue')
points(lmm,  type = 'b', col = 'darkred')
```

```{r t}

```


# L

```{r L, eval = FALSE, include = FALSE}
pi0 <- sum(gaba == 0)/length(gaba)
pi1 <- sum(gaba == 1)/length(gaba)


nurf <- 
  lapply(1:12, 
         function(x){
           pro <- randomForest(as.matrix(pc1$scores[, 1:x]), proximity = TRUE)$prox
           pcR <- princomp(pro)
           el1 <- getElbows(pcR$sdev, plot = FALSE)[1]
           hR <- hmc(pcR$scores[, 1:el1], modelNames = c('VVV'), maxDepth = 2)
           hR$dat$labels$col-1
         })

nmc <- 
  lapply(1:12, 
         function(x){
           h <- hmc(pc1$scores[, 1:x], modelNames = if(x == 1){'V'} else {c('VVV', 'VVI')}, maxDepth = 2)
           h$dat$labels$col-1
         })

b1 <- 
  lapply(1:12,
         function(x){
           if(x == 1){
             mu0 <- colMeans(as.matrix(pc1$scores[gaba == 0,1:x]))
             sd0 <- sd(pc1$scores[gaba == 0,1:x])

             mu1 <- colMeans(as.matrix(pc1$scores[gaba == 1,1:x]))
             sd1 <- sd(pc1$scores[gaba == 1,1:x])


             tmp <- cbind(
               pi0 * dnorm(pc1$scores[,1:x], mean = mu0, sd = sd0),
               pi1 * dnorm(pc1$scores[,1:x], mean = mu1, sd = sd1)
             )

             tmpD <- apply(tmp, 1, sum)
             post <- tmp / tmpD

           } else {
  
             mu0 <- colMeans(as.matrix(pc1$scores[gaba == 0,1:x]))
             sig0 <- cov(pc1$scores[gaba == 0,1:x])
  
             mu1 <- colMeans(as.matrix(pc1$scores[gaba == 1,1:x]))
             sig1 <- cov(pc1$scores[gaba == 1,1:x])
  
             tmp <- cbind(
               pi0 * dmvnorm(pc1$scores[,1:x], mean = mu0, sigma = sig0),
               pi1 * dmvnorm(pc1$scores[,1:x], mean = mu1, sigma = sig1)
             )

             tmpD <- apply(tmp, 1, sum)
             post <- tmp / tmpD

           }
           classi <- apply(post, 1, which.max) - 1
           return(classi)
         })
          





plot(x = 1:12, y = seq(0,0.55,length = 12), type = 'n', xlab = expression(hat(d)), ylab = "L")
points(sapply(b1, function(x) sum(x != gaba)/length(gaba)), type = 'b', )
points(sapply(nmc, function(x) sum(x != gaba)/length(gaba)), type = 'b')
points(sapply(nurf, function(x) sum(x != gaba)/length(gaba)), type = 'b')
```


